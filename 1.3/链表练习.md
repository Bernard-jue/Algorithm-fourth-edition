**1.3.18**  
>删除x的后续节点,即x指向了x后面的后面

**1.3.19**
```java
public void deleteLast()
{
  if(first==null)
    throw new RuntimeException();
  if(first.next==null)
  {
    first=null;
    return;
  }
  for (Node x = first; ; x=x.next) 
  {
    if(x.next.next==null)
    {
      x.next=x.next.next;
      return;
    }
  }
}
```

**1.3.20**
```java
public void delete(int k)
{
  if(first==null || k<=0)
    throw new RuntimeException();
  if(k==1)
  {
    first=first.next;
    return;
  }
  k--;
  Node current=first;
  while(current!=null && --k>0)//达到的效果是next了k-2次,到达被删除元素的前一个
  {
    current=current.next;
  }
  if(k!=0 || current==null || current.next==null)//要删除元素,要删除元素的前一个元素不能为null
    return;
  current.next=current.next.next;
}
```

**1.3.21**
```java
public boolean find(Node x,String key)
{
  for(Node current=x;current!=null;current=current.next)
  {
    if(current.item==key)
      return true;
  }
  return false;
}
```
**1.3.22**
>插入结点t,并且使它成为x的后续节点

**1.3.23**
>在更新t.next时,x.next已经不再指向x的后续节点,而是指向t本身.  相当于t.next=t,一个环

**1.3.24**
```java
public void removeAfter(Node x)
{
  if(x==null || x.next==null)
    return;
  Node current=x.next;
  Node next=current.next;
  x.next=null;
  while(current.next!=null)
  {
    current=null;
    current=next;
    next=next.next;
  }
}
```
**1.3.25**
```java
public void insertAfter(Node x,Node y)
{
  if(x==null || y==null)
    return;
  y.next=x.next;
  x.next=y;
}
```
**1.3.26**
```java
public void remove(Node x,String key)
{
  while(x!=null && x.item==key)
  {
    x=x.next;
  }
  Node current=x;
  Node node;
  while(current!=null && current.next!=null)
  {
    node=current.next;
    if(node.item==key)
      current.next=node.next;
    else
      current=node;
  }
}
```


